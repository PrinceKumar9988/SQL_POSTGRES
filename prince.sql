CREATE TABLE worker(
WORKER_ID SERIAL PRIMARY KEY,
FIRST_NAME CHAR(25),
LAST_NAME CHAR(25),
SALARY INT,
JOINING_DATE TIMESTAMP,
DEPARTMENT CHAR(25)
);


INSERT INTO worker
(WORKER_ID, FIRST_NAME, LAST_NAME, SALARY, JOINING_DATE, DEPARTMENT) VALUES
(001,'Prince', 'Kumar', 100000, '2021-02-09 14:30:15
', 'HR'),
(002,'Shashank', 'Kumar', 10000, '2020-07-31 14:30:15
', 'Accounts'),
(003,'pravesh', 'Kumar', 40000, '2023-02-07 14:30:15
', 'Developer'),
(004,'Mohit', 'Sharma', 80000, '2025-02-09 14:30:15
', 'Admin'),
(005,'rohit', 'Tyagi', 150000, '2025-02-09 14:30:15
', 'Accounts'),
(006,'purohit', 'Kumar', 106000, '2025-02-09 14:30:15
', 'Backend'),
(007,'Shyam', 'Verma', 110000, '2025-02-09 14:30:15
', 'Accounts')

SELECT * FROM worker;

CREATE TABLE Bonus(
WORKER_REF_ID INT,
BONUS_AMOUNT INT,
BONUS_DATE TIMESTAMP,
FOREIGN KEY(WORKER_REF_ID) REFERENCES worker(WORKER_ID)
ON DELETE CASCADE
);

INSERT INTO Bonus(WORKER_REF_ID,BONUS_AMOUNT,
BONUS_DATE) VALUES 
(001,5000,'2025-02-08 17:30:15'),
(001,7000,'2025-02-09 14:30:15'),
(003,3000,'2025-02-19 14:30:15'),
(001,4500,'2025-01-29 14:30:15'),
(002,3500,'2025-01-09 14:30:15')

SELECT * FROM Bonus;


CREATE TABLE Title(
WORKER_REF_ID INT,
WORKER_TITLE CHAR(25),
AFFECTED_FROM TIMESTAMP,
FOREIGN KEY(WORKER_REF_ID) REFERENCES worker(WORKER_ID)
ON DELETE CASCADE

);

INSERT INTO Title (WORKER_REF_ID, WORKER_TITLE, AFFECTED_FROM) VALUES
(001, 'Manager','2021-06-09 19:30:15'),
(002,'Executive','2025-02-09 04:20:15'),
(003,'Executive','2022-09-19 09:50:15'),
(004,'Manager','2020-02-06 08:37:15'),
(005,'Manager','2023-02-09 14:30:15'),
(008,'ASST MANAGER','2025-02-09 14:30:15'),
(007,'Lead','2019-02-08 11:30:15')

-- DQL/DRL;

-- USING SELECT COMMAND WITHOUT USING FROM(DUAL TABLES)
-- EXAMPLES:-

SELECT 55+11;
SELECT NOW();


SELECT FIRST_NAME, LAST_NAME, SALARY FROM worker;
SELECT FIRST_NAME, LAST_NAME, SALARY FROM worker WHERE SALARY>100000;
SELECT FIRST_NAME, LAST_NAME, SALARY FROM worker WHERE SALARY BETWEEN 0 AND 100000;
SELECT FIRST_NAME, LAST_NAME, SALARY FROM worker WHERE DEPARTMENT='HR';
SELECT * FROM worker WHERE DEPARTMENT='HR' OR DEPARTMENT='Admin' OR DEPARTMENT='Accounts';

-- BETTER WAY(USING IN)
SELECT * FROM worker WHERE DEPARTMENT IN('HR','Admin', 'Accounts');

--NOT

SELECT * FROM worker WHERE DEPARTMENT NOT IN('HR','Admin', 'Accounts');

-- In case of NUll

SELECT * FROM worker WHERE DEPARTMENT IS NULL;

 -- WILDCARDS

SELECT * FROM worker WHERE FIRST_NAME LIKE '__i%';
SELECT * FROM worker WHERE FIRST_NAME LIKE '%i%';

-- SORTING USING ORDER BY

SELECT * FROM worker ORDER BY SALARY DESC;

-- ASC(by default)

SELECT * FROM worker ORDER BY SALARY;

--DISTINCT

SELECT DISTINCT DEPARTMENT FROM worker;

-- DATA GROUPING:-(GROUP BY)


--FIND NO OF EMPLOYEES WORKING IN EACH DEPARTMENT 
-- HERE DATA GROUPING(GROUP BY) IS USED AND IT IS USED WITH AGGREGATION FUNCTIONS
--AGGREGATION FUNCTION SUCH AS SUM(),MAX(),MIN(),AVG(),COUNT(),LENGTH()

SELECT DEPARTMENT,COUNT(*) FROM worker GROUP BY DEPARTMENT;  -- IT IS COMMON CONVENTION TO USE DEPARTMENT IN BOTH STARTING AND ENDING
SELECT DEPARTMENT,COUNT(DEPARTMENT) FROM worker GROUP BY DEPARTMENT; -- IF YOU WILL NOT USE AGGREGATION FUNCTION WITH GROUP BY THEN IT WILL WORK AS DISTINCT

SELECT DEPARTMENT, SUM(SALARY) FROM worker GROUP BY DEPARTMENT;
SELECT DEPARTMENT, MIN(SALARY) FROM worker GROUP BY DEPARTMENT;
SELECT DEPARTMENT, MAX(SALARY) FROM worker GROUP BY DEPARTMENT;
SELECT DEPARTMENT, AVG(SALARY) FROM worker GROUP BY DEPARTMENT;


-- GROUP BY HAVING
-- IF WE USE 'WHERE' FOR FILTERING WITH SELECT, SIMILARLY WE USE 'HAVING' FOR FILTERING HERE IN THE GROUP BY;
 
SELECT DEPARTMENT, COUNT(DEPARTMENT) FROM worker GROUP BY DEPARTMENT HAVING COUNT(DEPARTMENT)>1;
 


-- DML:-

-- PRIMARY KEY CONSTRAINT
-- FOREIGN KEY CONSTRAINT
-- UNIQUE
-- CHECK:- EXAMPLE CHECK
DEFAULT

CREATE TABLE ACCOUNT(
ID INT PRIMARY KEY,
NAME VARCHAR(255),
BALANCE INT,
CONSTRAINT ACC_BALANCE CHECK(BALANCE>1000)
);


INSERT INTO ACCOUNT(ID,NAME,BALANCE) VALUES
(1,'A',10000);

INSERT INTO ACCOUNT(ID,NAME,BALANCE) VALUES
(2,'B',100);  -- IT WILL NOT EXECUTE BCS BALANCE IS LESS THAN 1000


SELECT * FROM ACCOUNT;

-- DEFAULT

-- EXAMPLE OF DEFAULT:-

CREATE TABLE ACCOUNT1(
ACCOUNT_ID SERIAL PRIMARY KEY,
NAME VARCHAR(255),
BALANCE INT NOT NULL DEFAULT 0
);

INSERT INTO ACCOUNT1(ACCOUNT_ID,NAME) VALUES
(1,'A');

SELECT * FROM ACCOUNT1;

-- ALTER TABLE COMMANDS:-

-- ADD

--ADDING NEW COLOUMN
ALTER TABLE ACCOUNT1 ADD INTEREST FLOAT DEFAULT 0;


-- MODIFY

--1. MODIFY DATA TYPE:
ALTER TABLE ACCOUNT1 MODIFY INTEREST DOUBLE;-- for mysql
ALTER TABLE ACCOUNT1 ALTER COLUMN INTEREST SET DATA TYPE DOUBLE PRECISION;  -- for postgresql


--RENAME THE COLOUMN:-

ALTER TABLE ACCOUNT1 RENAME COLUMN INTEREST TO SAVINGS_INTEREST;

-- DROP

ALTER TABLE ACCOUNT1 DROP COLUMN SAVINGS_INTEREST;

-- RENAME THE TABLE:-

ALTER TABLE ACCOUNT1 RENAME TO ACCOUNT;


--  DML:-

CREATE TABLE CUSTOMER(
ID INT PRIMARY KEY,
CNAME VARCHAR(255),
ADDRESS VARCHAR(255),
GENDER CHAR(2),
CITY VARCHAR(255),
PINCODE INT
);

-- 


-- 1ST WAY

INSERT INTO CUSTOMER (ID,CNAME,ADDRESS,GENDER,CITY,PINCODE) VALUES
(1,'Prince','ABC','M','LUDHIANA',141015);


--2ND WAY
INSERT INTO CUSTOMER VALUES
(5,'RAGHU','ABCR','M','LUDHIANA',141115);

-- 3RS WAY

INSERT INTO CUSTOMER (ID,CNAME) VALUES
(6,'Prince');

SELECT * FROM CUSTOMER;

INSERT INTO CUSTOMER (ID,CNAME,ADDRESS,GENDER,CITY,PINCODE) VALUES
(2,'SHASHA','ABCD','M','LUDHIANA_CITY',141010),
(3,'MONU','ABCDE','M','MOHALI',141510),
(4,'SHASHANK','ABCDVFS','M','LUDHIANA_MAIN',141510)


-- UPDATE

UPDATE CUSTOMER SET ADDRESS='MNDFJUEF' WHERE ID=3;

-- TO UPDATE ALL ROWS:-

UPDATE CUSTOMER SET PINCODE=128368; -- TO UPDATE ALL ROWS SIMPLY DON'Y USE WHERE


-- DELETE

DELETE  FROM CUSTOMER


-- REFERENTIAL CONSTRAINTS:-

-- FOREIGN KEY :
-- ON DELETE CASCADE
-- ON DELETE SET NULL 

-- REPLACE: 
--THERE IS NO DIRECT REPLACE INTHE POSTGRES(Following is ACCORDANCE TO MYSQL
-- IT IS COMPLEX IN THE POSTGRES SQL TO USE REPLACE

-- 1. IF DATA ALREADY PRESENT, REPLACE
-- 2. IF DATA NOT PRESENT, INSERT;


CREATE TABLE CUSTOMER1(
ID INT PRIMARY KEY,
CNAME VARCHAR(255),
ADDRESS VARCHAR(255),
GENDER CHAR(2),
CITY VARCHAR(255),
PINCODE INT
);

INSERT INTO CUSTOMER1 (ID,CNAME,ADDRESS,GENDER,CITY,PINCODE) VALUES
(2,'SHASHA','ABCD','M','LUDHIANA_CITY',141010),
(3,'MONU','ABCDE','M','MOHALI',141510),
(4,'SHASHANK','ABCDVFS','M','LUDHIANA_MAIN',141510)

SELECT * FROM CUSTOMER1;

REPLACE INTO CUSTOMER1 (ID,CNAME,ADDRESS,GENDER,CITY,PINCODE) VALUES 
(1,'Manu arora','HFYEB','M','CHANDIAGRH',432878)

REPLACE INTO CUSTOMER1 (ID,CNAME,ADDRESS) VALUES 
(1,'Manu arora','HFYEB')

REPLACE INTO CUSTOMER1 SET ID=1300,CNAME='MAC',CITY='LDH';

-- WHAT IS DIFFERENCE BETWEEN REPLACE AND UPDATE:-
-- IN REPLACE IF WE HAVE DONOT HAVE DATA THEN IT CREATES THE DATA(BY INSERTION) BUT IN UPDATE IT WILL DO NOTHING




-- JOINS


-- JOINS:- TO APPLY JOINS, THERE SHOULD BE A COMMON ATTRIBUTE BETWEEN TWO TABLES(FOREIGN KEY)

CREATE TABLE Departments (
    DepartmentID INT PRIMARY KEY,
    DepartmentName VARCHAR(50)
);
INSERT INTO Departments (DepartmentID, DepartmentName) VALUES
(101, 'HR'),
(102, 'IT'),
(104, 'Finance'),
(105, 'FinCORP'),
(106, 'ACCOUNTS'),
(108, 'Devloper');








CREATE TABLE Employees (
    EmployeeID INT PRIMARY KEY,
    Name VARCHAR(50),
    DepartmentID INT,
    FOREIGN KEY (DepartmentID) REFERENCES Departments(DepartmentID) ON DELETE CASCADE
);


INSERT INTO Employees (EmployeeID, Name, DepartmentID) VALUES
(1, 'John', 101),
(2, 'Alice', 102),
(3, 'Bob', 104),
(4, 'Eve', 102);

SELECT * FROM Departments ;
SELECT * FROM Employees;




-- INNER JOIN

SELECT C.*, O.* FROM Departments AS C INNER JOIN Employees AS O ON C.DepartmentID=O.DepartmentID;

-- OUTER JOIN:-
   -- LEFT JOIN

      SELECT C.*, O.* FROM Departments AS C LEFT JOIN Employees AS O ON C.DepartmentID=O.DepartmentID;

   -- RIGHT JOIN:-

      SELECT C.*, O.* FROM Departments AS C RIGHT JOIN Employees AS O ON C.DepartmentID=O.DepartmentID;

   -- FULL JOIN:- 

       SELECT C.*, O.* FROM Departments AS C FULL JOIN Employees AS O ON C.DepartmentID=O.DepartmentID; -- In postgresql we have FULL JOIN as a keyword that we can use to write sql query but in mysql we have to do union of LEFT JOIN AND RIGHT JOIN. 
	   

-- CROSS JOIN:- It is basically cartesian product of both the tables.
-- If left table has m rows and right table has n rows then resultant table will have m*n rows.

       SELECT C.* , O.* FROM Departments AS C CROSS JOIN Employees AS O;



-- SELF JOIN:-(v.imp look at the ss(Notes))
-- self join can be done with the help of the inner join or left join


-- Employee manager relationship
SELECT e1.EmployeeID AS Employee, e1.Name AS EmployeeName, 
       e2.EmployeeID AS ManagerID, e2.Name AS ManagerName
FROM Employees e1
LEFT JOIN Employees e2 ON e1.ManagerID = e2.EmployeeID;    -- important to understand after ON

--or 

SELECT e1.EmployeeID, e1.Name AS Employee, e2.Name AS Manager
FROM Employees e1
INNER JOIN Employees e2 ON e1.ManagerID = e2.EmployeeID;


-- SET OPERATIONS:-

-- ðŸ“Œ Is it Important to Have the Same Columns in Set Operations (UNION, INTERSECT, MINUS)?
-- Yes! In SQL, when performing set operations like UNION, INTERSECT, and MINUS (also called EXCEPT in PostgreSQL and MySQL), both tables must have:

-- 1ï¸âƒ£ The same number of columns
-- 2ï¸âƒ£ The same data types in corresponding columns
-- 3ï¸âƒ£ Compatible column order

-- No duplicates are allowed in sets

-- There r 3 types of SET operations:-

-- UNION
-- INTERSECTION
-- MINUS



CREATE TABLE Employees_2023 (
    EmployeeID INT PRIMARY KEY,
    Name VARCHAR(50)
);

INSERT INTO Employees_2023 (EmployeeID, Name) VALUES
(1, 'Alice'),
(2, 'Bob'),
(3, 'Charlie'),
(4, 'David');


CREATE TABLE Employees_2024 (
    EmployeeID INT PRIMARY KEY,
    Name VARCHAR(50)
);

INSERT INTO Employees_2024 (EmployeeID, Name) VALUES
(3, 'Charlie'),
(4, 'David'),
(5, 'Eve'),
(6, 'Frank');

SELECT * FROM Employees_2023;
SELECT * FROM Employees_2024;


-- UNION:-

-- UNION SEEMS QUITE SIMILAR TO THE FULL JOIN(VENN DIAGRAM)

SELECT * FROM Employees_2023
UNION 
SELECT * FROM Employees_2024;

-- INTERSECT:-

-- INTERSECT SEEMS QUITE SIMILAR TO THE INNER JOIN(VENN DIAGRAM)


SELECT * FROM Employees_2023
INTERSECT
SELECT * FROM Employees_2024;
-- IN POSTGRES SQL WE HAVE INTERSECT AS A KEYWORD BUT IN MYSQL WE DO IT USING INNER JOIN(NOTES).


-- MINUS:-

-- THERE IS NO MINUS IN POSTGRES SQL SO WE HAVE TO DO IT USING LEFT JOIN.

SELECT * FROM Employees_2023  EXCEPT SELECT * FROM Employees_2024;  -- EXCEPT IS USED IN POSTGRES TO MINUS







-- SUB- QUERIES:- SUB-QUERIES ARE BASICALLY ALTERNATIVES OF THE JOINS


-- 1. Outer query depends on inner query.  (Q1(Q2))
-- 2. Alternative to joins.

-- EXAMPLE:-

SELECT * FROM table WHERE id IN(SELECT id FROM table WHERE name="lak"); -- here outer query depends on inner query

-- sub-queries mainly work in 3 clauses:-

-- 1. Inside a WHERE clause.
-- 2. Inside a FROM clause.
-- 3. Inside a SELECT clause.


-- WHERE CLAUSE:-



   -- FIND ALL THE EMPLOYEES GREATER THAN AGE OF 30, ONE IS SIMPLER WAY OF FINDING ALL THE EMPLOYEES.i.e. SELECT EMPLOYEES_NAME FROM EMPLOYEES-TABLE WHERE AGE>30; BUT IT CAN BE DONE WITH THE HELP OF SUB-QUERIES AS WELL

   --EXAMPLE:-

SELECT * FROM EMPLOYEE_TABLE WHERE AGE IN(SELECT AGE FROM EMPOYEE_TABLE WHERE AGE>30);

   -- EMPLOYEE DETAIL WORKING IN MORE THAN 1 PROJECT:-

SELECT * FROM EMPLOYEE_TABLE WHERE ID IN(SELECT ID FROM EMPLOYEE_TABLE GROUP BY ID HAVING COUNT(ID)>1);

   -- SINGLE VALUE SUB-QUERY:-IT MEANS U WILL GET SINGLE VALUE FROM INNER QUERY

SELECT AGE FROM EMPLOYEE_TABLE WHERE AGE >(SELELCT AVG(AGE) FROM EMPLOYEE_TABLE);   



   
-- FROM CLAUSE:-  (DERIVED sub-query)

SELECT MAX(AGE) FROM (SELECT * FROM EMPLOYEE_TABLE WHERE FIRST_NAME LIKE '__A%') AS temp; -- IN DERIVED SUB-QUERY IN FROM CLAUSE YOU HAVE TO USE AS AS ALIAS BCS IN INNER QUERY IS WORKING AS TABLE FROM WHERE ROWS WILL BE SELECTED. 



-- CO-RELATED SUB-QUERY:-

-- Q1(Q2):- GENERALLY OUTER QUERY DEPENDS ON INNER QUERY IN THE SUB-QUERIES BUT IN CO-RELATED SUB-QUERY THERE IS CO-RELATION .I.E. BOTH THE QUERIES DEPEND ON EACH OTHER

--  EXAMPLE:- 3RD OLDEST EMPLYEE IN A EMPLOYEE_TABLE :-


SELECT * FROM EMPLOYEE_TABLE AS E1 WHERE 3=(SELECT COUNT(AGE) FROM EMPLOYEE_TABLE AS E2 WHERE E2.AGE>=E1.AGE);






-- VIEWS IN DATABASE:-


    -- IN DBMS ARCHITECTURE WE HAVE 3 LEVELS OF ABSTRACTION 1.PHYSICAL LEVEL   2.CONCEPTUAL LEVEL.  3.VIEW LEVEL(EXTERNAL LEVEL) OR END USER.


    -- CREATING A VIEW:-

CREATE VIEW AS CUSTOM_VIEW SELECT FIRST_NAME, AGE FROM EMPLOYEE_TABLE;

    -- VIEWING THE VIEW:-

	SELECT * FROM CUSTOM_VIEW;

	-- ALTERING THE VIEW:-

	ALTER VIEW CUSTOM_VIEW AS SELECT FIRST_NAME, LAST_NAME, AGE FROM EMPLOYEE_TABLE;

	SELECT * FROM CUSTOM_VIEW;


	-- DROP VIEWS:-

	DROP VIEW IF EXISTS CUSTOM_VIEW;









