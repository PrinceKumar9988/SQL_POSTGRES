CREATE TABLE worker(
WORKER_ID SERIAL PRIMARY KEY,
FIRST_NAME CHAR(25),
LAST_NAME CHAR(25),
SALARY INT,
JOINING_DATE TIMESTAMP,
DEPARTMENT CHAR(25)
);


INSERT INTO worker
(WORKER_ID, FIRST_NAME, LAST_NAME, SALARY, JOINING_DATE, DEPARTMENT) VALUES
(001,'Prince', 'Kumar', 100000, '2021-02-09 14:30:15
', 'HR'),
(002,'Shashank', 'Kumar', 10000, '2020-07-31 14:30:15
', 'Accounts'),
(003,'pravesh', 'Kumar', 40000, '2023-02-07 14:30:15
', 'Developer'),
(004,'Mohit', 'Sharma', 80000, '2025-02-09 14:30:15
', 'Admin'),
(005,'rohit', 'Tyagi', 150000, '2025-02-09 14:30:15
', 'Accounts'),
(006,'purohit', 'Kumar', 106000, '2025-02-09 14:30:15
', 'Backend'),
(007,'Shyam', 'Verma', 110000, '2025-02-09 14:30:15
', 'Accounts')

SELECT * FROM worker;

CREATE TABLE Bonus(
WORKER_REF_ID INT,
BONUS_AMOUNT INT,
BONUS_DATE TIMESTAMP,
FOREIGN KEY(WORKER_REF_ID) REFERENCES worker(WORKER_ID)
ON DELETE CASCADE
);

INSERT INTO Bonus(WORKER_REF_ID,BONUS_AMOUNT,
BONUS_DATE) VALUES 
(001,5000,'2025-02-08 17:30:15'),
(001,7000,'2025-02-09 14:30:15'),
(003,3000,'2025-02-19 14:30:15'),
(001,4500,'2025-01-29 14:30:15'),
(002,3500,'2025-01-09 14:30:15')

SELECT * FROM Bonus;


CREATE TABLE Title(
WORKER_REF_ID INT,
WORKER_TITLE CHAR(25),
AFFECTED_FROM TIMESTAMP,
FOREIGN KEY(WORKER_REF_ID) REFERENCES worker(WORKER_ID)
ON DELETE CASCADE

);

INSERT INTO Title (WORKER_REF_ID, WORKER_TITLE, AFFECTED_FROM) VALUES
(001, 'Manager','2021-06-09 19:30:15'),
(002,'Executive','2025-02-09 04:20:15'),
(003,'Executive','2022-09-19 09:50:15'),
(004,'Manager','2020-02-06 08:37:15'),
(005,'Manager','2023-02-09 14:30:15'),
(008,'ASST MANAGER','2025-02-09 14:30:15'),
(007,'Lead','2019-02-08 11:30:15')

-- DQL/DRL;

-- USING SELECT COMMAND WITHOUT USING FROM(DUAL TABLES)
-- EXAMPLES:-

SELECT 55+11;
SELECT NOW();


SELECT FIRST_NAME, LAST_NAME, SALARY FROM worker;
SELECT FIRST_NAME, LAST_NAME, SALARY FROM worker WHERE SALARY>100000;
SELECT FIRST_NAME, LAST_NAME, SALARY FROM worker WHERE SALARY BETWEEN 0 AND 100000;
SELECT FIRST_NAME, LAST_NAME, SALARY FROM worker WHERE DEPARTMENT='HR';
SELECT * FROM worker WHERE DEPARTMENT='HR' OR DEPARTMENT='Admin' OR DEPARTMENT='Accounts';

-- BETTER WAY(USING IN)
SELECT * FROM worker WHERE DEPARTMENT IN('HR','Admin', 'Accounts');

--NOT

SELECT * FROM worker WHERE DEPARTMENT NOT IN('HR','Admin', 'Accounts');

-- In case of NUll

SELECT * FROM worker WHERE DEPARTMENT IS NULL;

 -- WILDCARDS

SELECT * FROM worker WHERE FIRST_NAME LIKE '__i%';
SELECT * FROM worker WHERE FIRST_NAME LIKE '%i%';

-- SORTING USING ORDER BY

SELECT * FROM worker ORDER BY SALARY DESC;

-- ASC(by default)

SELECT * FROM worker ORDER BY SALARY;

--DISTINCT

SELECT DISTINCT DEPARTMENT FROM worker;

-- DATA GROUPING:-(GROUP BY)


--FIND NO OF EMPLOYEES WORKING IN EACH DEPARTMENT 
-- HERE DATA GROUPING(GROUP BY) IS USED AND IT IS USED WITH AGGREGATION FUNCTIONS
--AGGREGATION FUNCTION SUCH AS SUM(),MAX(),MIN(),AVG(),COUNT(),LENGTH()

SELECT DEPARTMENT,COUNT(*) FROM worker GROUP BY DEPARTMENT;  -- IT IS COMMON CONVENTION TO USE DEPARTMENT IN BOTH STARTING AND ENDING
SELECT DEPARTMENT,COUNT(DEPARTMENT) FROM worker GROUP BY DEPARTMENT; -- IF YOU WILL NOT USE AGGREGATION FUNCTION WITH GROUP BY THEN IT WILL WORK AS DISTINCT

SELECT DEPARTMENT, SUM(SALARY) FROM worker GROUP BY DEPARTMENT;
SELECT DEPARTMENT, MIN(SALARY) FROM worker GROUP BY DEPARTMENT;
SELECT DEPARTMENT, MAX(SALARY) FROM worker GROUP BY DEPARTMENT;
SELECT DEPARTMENT, AVG(SALARY) FROM worker GROUP BY DEPARTMENT;


-- GROUP BY HAVING
-- IF WE USE 'WHERE' FOR FILTERING WITH SELECT, SIMILARLY WE USE 'HAVING' FOR FILTERING HERE IN THE GROUP BY;
 
SELECT DEPARTMENT, COUNT(DEPARTMENT) FROM worker GROUP BY DEPARTMENT HAVING COUNT(DEPARTMENT)>1;
 


-- DML:-

-- PRIMARY KEY CONSTRAINT
-- FOREIGN KEY CONSTRAINT
-- UNIQUE
-- CHECK:- EXAMPLE CHECK
DEFAULT

CREATE TABLE ACCOUNT(
ID INT PRIMARY KEY,
NAME VARCHAR(255),
BALANCE INT,
CONSTRAINT ACC_BALANCE CHECK(BALANCE>1000)
);


INSERT INTO ACCOUNT(ID,NAME,BALANCE) VALUES
(1,'A',10000);

INSERT INTO ACCOUNT(ID,NAME,BALANCE) VALUES
(2,'B',100);  -- IT WILL NOT EXECUTE BCS BALANCE IS LESS THAN 1000


SELECT * FROM ACCOUNT;

-- DEFAULT

-- EXAMPLE OF DEFAULT:-

CREATE TABLE ACCOUNT1(
ACCOUNT_ID SERIAL PRIMARY KEY,
NAME VARCHAR(255),
BALANCE INT NOT NULL DEFAULT 0
);

INSERT INTO ACCOUNT1(ACCOUNT_ID,NAME) VALUES
(1,'A');

SELECT * FROM ACCOUNT1;

-- ALTER TABLE COMMANDS:-

-- ADD

--ADDING NEW COLOUMN
ALTER TABLE ACCOUNT1 ADD INTEREST FLOAT DEFAULT 0;


-- MODIFY

--1. MODIFY DATA TYPE:
ALTER TABLE ACCOUNT1 MODIFY INTEREST DOUBLE;-- for mysql
ALTER TABLE ACCOUNT1 ALTER COLUMN INTEREST SET DATA TYPE DOUBLE PRECISION;  -- for postgresql


--RENAME THE COLOUMN:-

ALTER TABLE ACCOUNT1 RENAME COLUMN INTEREST TO SAVINGS_INTEREST;

-- DROP

ALTER TABLE ACCOUNT1 DROP COLUMN SAVINGS_INTEREST;

-- RENAME THE TABLE:-

ALTER TABLE ACCOUNT1 RENAME TO ACCOUNT;


--  DML:-

CREATE TABLE CUSTOMER(
ID INT PRIMARY KEY,
CNAME VARCHAR(255),
ADDRESS VARCHAR(255),
GENDER CHAR(2),
CITY VARCHAR(255),
PINCODE INT
);

-- 


-- 1ST WAY

INSERT INTO CUSTOMER (ID,CNAME,ADDRESS,GENDER,CITY,PINCODE) VALUES
(1,'Prince','ABC','M','LUDHIANA',141015);


--2ND WAY
INSERT INTO CUSTOMER VALUES
(5,'RAGHU','ABCR','M','LUDHIANA',141115);

-- 3RS WAY

INSERT INTO CUSTOMER (ID,CNAME) VALUES
(6,'Prince');

SELECT * FROM CUSTOMER;

INSERT INTO CUSTOMER (ID,CNAME,ADDRESS,GENDER,CITY,PINCODE) VALUES
(2,'SHASHA','ABCD','M','LUDHIANA_CITY',141010),
(3,'MONU','ABCDE','M','MOHALI',141510),
(4,'SHASHANK','ABCDVFS','M','LUDHIANA_MAIN',141510)


-- UPDATE

UPDATE CUSTOMER SET ADDRESS='MNDFJUEF' WHERE ID=3;

-- TO UPDATE ALL ROWS:-

UPDATE CUSTOMER SET PINCODE=128368; -- TO UPDATE ALL ROWS SIMPLY DON'Y USE WHERE


-- DELETE

DELETE  FROM CUSTOMER


-- REFERENTIAL CONSTRAINTS:-

-- FOREIGN KEY :
-- ON DELETE CASCADE
-- ON DELETE SET NULL 

-- REPLACE: 
--THERE IS NO DIRECT REPLACE INTHE POSTGRES(Following is ACCORDANCE TO MYSQL
-- IT IS COMPLEX IN THE POSTGRES SQL TO USE REPLACE

-- 1. IF DATA ALREADY PRESENT, REPLACE
-- 2. IF DATA NOT PRESENT, INSERT;


CREATE TABLE CUSTOMER1(
ID INT PRIMARY KEY,
CNAME VARCHAR(255),
ADDRESS VARCHAR(255),
GENDER CHAR(2),
CITY VARCHAR(255),
PINCODE INT
);

INSERT INTO CUSTOMER1 (ID,CNAME,ADDRESS,GENDER,CITY,PINCODE) VALUES
(2,'SHASHA','ABCD','M','LUDHIANA_CITY',141010),
(3,'MONU','ABCDE','M','MOHALI',141510),
(4,'SHASHANK','ABCDVFS','M','LUDHIANA_MAIN',141510)

SELECT * FROM CUSTOMER1;

REPLACE INTO CUSTOMER1 (ID,CNAME,ADDRESS,GENDER,CITY,PINCODE) VALUES 
(1,'Manu arora','HFYEB','M','CHANDIAGRH',432878)

REPLACE INTO CUSTOMER1 (ID,CNAME,ADDRESS) VALUES 
(1,'Manu arora','HFYEB')

REPLACE INTO CUSTOMER1 SET ID=1300,CNAME='MAC',CITY='LDH';

-- WHAT IS DIFFERENCE BETWEEN REPLACE AND UPDATE:-
-- IN REPLACE IF WE HAVE DONOT HAVE DATA THEN IT CREATES THE DATA(BY INSERTION) BUT IN UPDATE IT WILL DO NOTHING


-- JOINS:- TO APPLY JOINS, THERE SHOULD BE A COMMON ATTRIBUTE BETWEEN TWO TABLES(FOREIGN KEY)


-- SET OPERATIONS:-   









